<!-- bootstrap -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
  integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
  crossorigin="anonymous"></script>

<!-- back to top (con guardas para evitar errores cuando el botón no existe) -->
<script>
(function(){
  const mybutton = document.getElementById("btn-back-to-top");
  if (!mybutton) return; // ⬅️ Evita errores si el botón no está en esta vista

  function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
      mybutton.style.display = 'block';
    } else {
      mybutton.style.display = 'none';
    }
  }

  window.addEventListener('scroll', scrollFunction, { passive: true });
  mybutton.addEventListener("click", function backToTop() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  });

  // estado inicial
  scrollFunction();
})();
</script>

<!-- Youtube Lite -->
<script src="https://cdn.jsdelivr.net/npm/youtube-lite/dist/youtube-lite.min.js"></script>

<!-- Bloqueo Renderizado -->
<script defer type="text/javascript" src="https://kit.fontawesome.com/77600c43ad.js" id="kit-awesome"></script>

<!-- ✅ Script del navbar -->
<script src="./scriptNavbar.ejs" defer></script>


<script>
  document.addEventListener('DOMContentLoaded', () => {
    const section  = document.getElementById('cardsSection');
    const viewport = document.querySelector('.cards-viewport');
    const cards    = Array.from(document.querySelectorAll('#cardsSection .card'));
    if (!section || !viewport || cards.length === 0) return;
  
    // --- 1) escena alta
    section.style.setProperty('--cards', String(cards.length));
  
    // --- 2) parámetros de “feel”
    const SPREAD_X = 0.28;   // separación horizontal por “paso” (en anchos de viewport)
    const SCALE_MIN = 0.92;  // escala mínima cuando está lejos del foco
    const BLUR_MAX = 0.8;    // blur máximo fuera de foco (poné 0 si no querés nada)
    const EASE = t => 1 - Math.pow(1 - t, 3); // easeOutCubic (si quisieras mezclar)
  
    // --- 3) estado
    let ticking = false;
    let lastNearest = 0;
    const animatingCards = new Set(); // cards que están en animación de salida
  
    // helpers
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function getLocalT(){
      const rect = section.getBoundingClientRect();
      const vh = window.innerHeight || document.documentElement.clientHeight;
      const sectionTopAbs = window.scrollY + rect.top;
      const y = clamp(window.scrollY + vh/2 - sectionTopAbs, 0, rect.height - 1);
      return clamp(y / vh, 0, cards.length - 1); // 0..N-1
    }
  
    // animación de “pase de página” hacia la izquierda
    function pageLeaveLeft(card){
      if (!card || animatingCards.has(card)) return;
      animatingCards.add(card);
  
      // Congelamos el transform actual (el que dejó el render en el frame anterior)
      // y aplicamos una transición puntual de salida hacia la izquierda.
      const DURATION = 520; // ms
      // Ponemos una transición SOLO para esta animación puntual
      card.style.transition = 'transform 520ms cubic-bezier(.22,.75,.25,1)';
      // Empujamos al siguiente frame para que tome el transform actual como "from"
      requestAnimationFrame(() => {
        // la mandamos a la izquierda con leve rotación y leve shrink (sin opacidad)
        card.style.transform = 'translate(-50%,-50%) translateX(-140vw) rotate(-6deg) scale(0.9)';
      });
  
      // Al finalizar, limpiamos y volvemos a ceder control al render
      setTimeout(() => {
        card.style.transition = ''; // limpiamos transition puntual
        animatingCards.delete(card);
      }, DURATION + 40);
    }
  
    function render(){
      ticking = false;
      const t = getLocalT();          // 0..N-1 (float)
      const nearest = Math.round(t);  // card “activa” (entera)
  
      // Si cambió la card activa => animá la que salió (si existe)
      if (nearest !== lastNearest) {
        const outgoing = cards[lastNearest];
        // Efecto de página SIEMPRE hacia la izquierda (como pediste)
        if (outgoing) pageLeaveLeft(outgoing);
        lastNearest = nearest;
      }
  
      const w = window.innerWidth || document.documentElement.clientWidth;
  
      cards.forEach((card, i) => {
        // si la card está animándose, no la toques
        if (animatingCards.has(card)) return;
  
        const d = i - t;           // distancia continua al foco
        const ad = Math.abs(d);
  
        // desplazamiento lateral respecto del centro de la escena
        const tx = d * (w * SPREAD_X);
  
        // escala y blur según distancia (sin opacidad)
        const s  = 1 - (1 - SCALE_MIN) * clamp(ad, 0, 1);
        const bl = BLUR_MAX * clamp(ad, 0, 1);
  
        // z-index: la más cercana arriba
        const z  = 1000 + (cards.length - Math.floor(ad * 10));
  
        card.style.transform = `translate(-50%,-50%) translateX(${tx}px) scale(${s})`;
        card.style.filter    = `blur(${bl}px)`;
        card.style.zIndex    = z;
  
        card.classList.toggle('active', i === nearest);
        card.classList.toggle('past',   i <  nearest);
      });
    }
  
    function onScroll(){
      if (!ticking){
        ticking = true;
        requestAnimationFrame(render);
      }
    }
  
    // eventos
    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onScroll, { passive: true });
  
    // click para centrar una card (opcional)
    cards.forEach((c, i) => {
      c.addEventListener('click', () => {
        const vh = window.innerHeight || document.documentElement.clientHeight;
        const rect = section.getBoundingClientRect();
        const sectionTopAbs = window.scrollY + rect.top;
        const targetY = sectionTopAbs + (i * vh) - vh/2;
        window.scrollTo({ top: targetY, behavior: 'smooth' });
      });
      c.addEventListener('dragstart', e => e.preventDefault());
    });
  
    // inicial
    lastNearest = Math.round(getLocalT());
    render();
  });
  </script>
  