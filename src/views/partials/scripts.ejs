<!-- bootstrap -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
  integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
  crossorigin="anonymous"></script>

<!-- back to top (con guardas para evitar errores cuando el botón no existe) -->
<script>
(function(){
  const mybutton = document.getElementById("btn-back-to-top");
  if (!mybutton) return; // ⬅️ Evita errores si el botón no está en esta vista

  function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
      mybutton.style.display = 'block';
    } else {
      mybutton.style.display = 'none';
    }
  }

  window.addEventListener('scroll', scrollFunction, { passive: true });
  mybutton.addEventListener("click", function backToTop() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  });

  // estado inicial
  scrollFunction();
})();
</script>

<!-- Youtube Lite -->
<script src="https://cdn.jsdelivr.net/npm/youtube-lite/dist/youtube-lite.min.js"></script>

<!-- Bloqueo Renderizado -->
<script defer type="text/javascript" src="https://kit.fontawesome.com/77600c43ad.js" id="kit-awesome"></script>

<!-- ✅ Script del navbar -->
<script src="./scriptNavbar.ejs" defer></script>




<script>
  /**
   * Sticky scene con suavizado:
   * - Lerp del progreso (SMOOTHING) = “inercia” al cambiar de card.
   * - Easing en la escala.
   * - Page-leave a la izquierda sólo en no-touch (para no frenar móviles).
   * - Opcional: micro-snap al frenar el scroll (SNAP_ON_IDLE).
   */
  document.addEventListener('DOMContentLoaded', () => {
    const section  = document.getElementById('cardsSection');
    const viewport = document.querySelector('.cards-viewport');
    const cards    = Array.from(document.querySelectorAll('#cardsSection .card'));
    if (!section || !viewport || cards.length === 0) return;
  
    // Altura de escena = N * 100vh (o svh si tu CSS la usa por @supports)
    section.style.setProperty('--cards', String(cards.length));
  
    // ===== Parámetros de "feel" =====
    const SPREAD_X = 0.28;         // separación horizontal por “paso” (en vw)
    const SCALE_MIN = 0.94;        // escala mínima fuera de foco
    const PAGE_LEAVE_MS = 420;     // duración del “pase de página” (no-touch)
    const isTouch = (('ontouchstart' in window) || navigator.maxTouchPoints > 0);
  
    // Suavizado (lerp): más alto = más “manteca”; demasiado alto = sensación gomosa
    const SMOOTHING = isTouch ? 0.14 : 0.20;
  
    // Micro-snap al detenerse (opcional, suave)
    const SNAP_ON_IDLE = true;
    const SNAP_IDLE_MS = 140;      // tiempo sin scroll para snap
    const SNAP_EPS     = 0.12;     // si el progreso está cerca (en fracción de card), centra
  
    // Easing para la escala (más orgánico que lineal)
    const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
  
    // ===== Estado y cachés =====
    let vh = window.innerHeight || document.documentElement.clientHeight;
    let vw = window.innerWidth  || document.documentElement.clientWidth;
    let sectionTopAbs = 0;
  
    let rawT = 0;          // progreso crudo 0..N-1 (desde scroll)
    let smoothT = 0;       // progreso suavizado (lerp)
    let lastNearest = 0;   // índice entero de la card “más cercana”
    let ticking = false;
    let idleTimer = null;
  
    const animatingCards = new Set(); // para el page-leave puntual
  
    function updateMetrics(){
      const r = section.getBoundingClientRect();
      sectionTopAbs = window.scrollY + r.top;
      vh = window.innerHeight || document.documentElement.clientHeight;
      vw = window.innerWidth  || document.documentElement.clientWidth;
    }
    updateMetrics();
  
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  
    // Progreso crudo 0..(N-1)
    function getLocalT(scrollY){
      const yCenter = scrollY + vh/2;
      const rel = clamp(yCenter - sectionTopAbs, 0, (cards.length * vh) - 1);
      return clamp(rel / vh, 0, cards.length - 1);
    }
  
    function pageLeaveLeft(card){
      if (isTouch) return;                     // desactivado en touch
      if (!card || animatingCards.has(card)) return;
      animatingCards.add(card);
      card.style.transition = `transform ${PAGE_LEAVE_MS}ms cubic-bezier(.22,.75,.25,1)`;
      requestAnimationFrame(() => {
        card.style.transform = 'translate3d(-50%, -50%, 0) translate3d(-140vw, 0, 0) rotate(-6deg) scale(0.9)';
      });
      setTimeout(() => {
        card.style.transition = '';
        animatingCards.delete(card);
      }, PAGE_LEAVE_MS + 40);
    }
  
    function render(){
      ticking = false;
  
      // Lerp del progreso
      smoothT += (rawT - smoothT) * SMOOTHING;
  
      const t = smoothT;                   // 0..N-1 (float suavizado)
      const nearest = Math.round(t);       // card “activa”
      if (nearest !== lastNearest) {
        const outgoing = cards[lastNearest];
        if (outgoing) pageLeaveLeft(outgoing);
        lastNearest = nearest;
      }
  
      const txFactor = vw * SPREAD_X;
  
      for (let i = 0; i < cards.length; i++){
        const card = cards[i];
        if (animatingCards.has(card)) continue; // no pisar animación puntual
  
        const d  = i - t;                 // distancia continua al foco
        const ad = Math.abs(d);
  
        // desplazamiento x
        const tx = d * txFactor;
  
        // escala con easing (ad normalizado a [0,1])
        const ad01 = Math.min(1, ad);
        const eased = easeOutCubic(1 - ad01); // 1 cerca del foco → 0 lejos
        const s = SCALE_MIN + (1 - SCALE_MIN) * eased;
  
        const z = 1000 + (cards.length - Math.floor(ad * 10));
  
        card.style.transform = `translate3d(-50%, -50%, 0) translate3d(${tx}px, 0, 0) scale(${s})`;
        card.style.zIndex    = z;
  
        card.classList.toggle('active', i === nearest);
        card.classList.toggle('past',   i <  nearest);
      }
  
      // Si el suavizado dejó muy cerca del target, “engancha” exacto para evitar micro-vibración
      if (Math.abs(rawT - smoothT) < 0.001) smoothT = rawT;
    }
  
    function scheduleRAF(){
      if (!ticking){
        ticking = true;
        requestAnimationFrame(render);
      }
    }
  
    // Micro-snap cuando el scroll se detiene cerca de una etapa
    function scheduleIdleSnap(){
      if (!SNAP_ON_IDLE) return;
      if (idleTimer) clearTimeout(idleTimer);
      idleTimer = setTimeout(() => {
        const stage = Math.round(rawT);
        const diff = Math.abs(rawT - stage);
        if (diff <= SNAP_EPS){
          // centra exactamente esa etapa
          const targetY = sectionTopAbs + (stage * vh) - vh/2;
          window.scrollTo({ top: targetY, behavior: 'smooth' });
        }
      }, SNAP_IDLE_MS);
    }
  
    function onScroll(){
      rawT = getLocalT(window.scrollY);
      scheduleRAF();
      scheduleIdleSnap();
    }
  
    function onResize(){
      updateMetrics();
      // Recalcular progreso con nuevas métricas y alinear el suavizado
      rawT = getLocalT(window.scrollY);
      if (Math.abs(smoothT - rawT) > 1) smoothT = rawT; // evita saltos grandes
      scheduleRAF();
    }
  
    // Eventos (pasivos: nunca bloqueamos el scroll nativo)
    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('resize', onResize, { passive: true });
  
    // Click: centrar una card
    cards.forEach((c, i) => {
      c.addEventListener('click', () => {
        const targetY = sectionTopAbs + (i * vh) - vh/2;
        window.scrollTo({ top: targetY, behavior: 'smooth' });
      }, { passive: true });
      c.addEventListener('dragstart', e => e.preventDefault());
    });
  
    // Inicial
    rawT = getLocalT(window.scrollY);
    smoothT = rawT;             // arrancar sin “arrastre”
    requestAnimationFrame(render);
  });
  </script>
  