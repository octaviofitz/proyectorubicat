<!-- bootstrap -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
  integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
  crossorigin="anonymous"></script>

<!-- back to top (con guardas para evitar errores cuando el botón no existe) -->
<script>
(function(){
  const mybutton = document.getElementById("btn-back-to-top");
  if (!mybutton) return; // ⬅️ Evita errores si el botón no está en esta vista

  function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
      mybutton.style.display = 'block';
    } else {
      mybutton.style.display = 'none';
    }
  }

  window.addEventListener('scroll', scrollFunction, { passive: true });
  mybutton.addEventListener("click", function backToTop() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  });

  // estado inicial
  scrollFunction();
})();
</script>

<!-- Youtube Lite -->
<script src="https://cdn.jsdelivr.net/npm/youtube-lite/dist/youtube-lite.min.js"></script>

<!-- Bloqueo Renderizado -->
<script defer type="text/javascript" src="https://kit.fontawesome.com/77600c43ad.js" id="kit-awesome"></script>

<!-- ✅ Script del navbar -->
<script src="./scriptNavbar.ejs" defer></script>


<script>
  document.addEventListener('DOMContentLoaded', () => {
      const section  = document.getElementById('cardsSection');
      const viewport = document.querySelector('.cards-viewport');
      const cards    = Array.from(document.querySelectorAll('#cardsSection .card'));
      if (!section || !viewport || cards.length === 0) return;
  
      // Config inicial
      section.style.setProperty('--cards', String(cards.length)); 
  
      // Parámetros
      const SPREAD_X       = 0.28;     // separación horizontal (en proporción del ancho)
      const SCALE_MIN      = 0.94;     // escala mínima
      const PAGE_LEAVE_MS  = 460;
      const isTouch        = (('ontouchstart' in window) || navigator.maxTouchPoints > 0);
  
      // Estado
      let ticking = false;
      let lastNearest = 0;
      const animatingCards = new Set();
  
      // Métricas
      let vh, vw, sectionTopAbs, animationUnitHeight, startOriginY;
  
      function updateMetrics(){
        vh = window.innerHeight || document.documentElement.clientHeight;
        vw = window.innerWidth  || document.documentElement.clientWidth;
  
        // Altura real del sticky viewport (100vh/100svh en desktop, 500px en mobile)
        animationUnitHeight = viewport.offsetHeight;
  
        // Posición absoluta de la sección y del viewport sticky
        const sectionRect  = section.getBoundingClientRect();
        sectionTopAbs      = window.scrollY + sectionRect.top;
  
        // ***** MODIFICACIÓN CLAVE AQUI *****
        // Queremos que t=0 (el inicio del scroll de cards) ocurra cuando
        // la parte superior de la sección de cards (sectionTopAbs) esté 
        // a (vh / 2) - (animationUnitHeight / 2) de distancia del top del viewport.
        
        // Esto calcula el punto de scroll Y en el que la card 1 está en el centro 
        // vertical de la pantalla.
        // La distancia que necesitamos scrollear antes de que t=0.
        const initialScrollOffset = (vh / 2); // Queremos el centro de la pantalla
  
        // El valor de 'startOriginY' debe ser el scrollY donde el efecto comienza.
        // El efecto comienza cuando sectionTopAbs es igual a initialScrollOffset.
        startOriginY = sectionTopAbs - initialScrollOffset;
        // **********************************
  
        // Altura mínima para que haya espacio de:
        // 1. Pre-scroll (para centrar la primera card)
        // 2. (N-1) transiciones de cards
        // 3. Post-scroll (para que la última card salga del centro)
        // Ajustamos la altura requerida para que haya espacio para que la última card se centre (cards.length - 1) * unitHeight, 
        // y luego espacio para que salga completamente (animationUnitHeight) + (vh / 2) de post-scroll.
        const requiredHeight = initialScrollOffset + ((cards.length - 1) * animationUnitHeight) + animationUnitHeight + (vh / 2);
  
        if (section.offsetHeight < requiredHeight) {
          section.style.height = `${requiredHeight}px`;
        }
      
        // Esto asegura que la card se quede 'sticky' en el centro del viewport 
        // (que es lo que se busca visualmente)
        viewport.style.top = `calc(50% - ${animationUnitHeight / 2}px)`;
  
      }
      updateMetrics();
  
      function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
  
      // t en [0, N-1] usando origen centro-a-centro
      function getLocalT(scrollY){
        // Aquí el cálculo de scrollDistance ya usa el nuevo startOriginY
        let scrollDistance = scrollY - startOriginY;
        
        // El máximo scroll animado es (N) * unitHeight.
        const maxScrollForAnimation = (cards.length) * animationUnitHeight; 
        const rel = clamp(scrollDistance, 0, maxScrollForAnimation);
        
        // t ahora puede ir hasta N.
        return rel / animationUnitHeight;
      }
  
      // Animación de salida a la izquierda (desktop)
      function pageLeaveLeft(card){
        if (isTouch || animatingCards.has(card)) return;
  
        animatingCards.add(card);
        card.style.transition = `transform ${PAGE_LEAVE_MS}ms cubic-bezier(.22,.75,.25,1)`;
  
        requestAnimationFrame(() => {
          card.style.transform = 'translate3d(-50%, -50%, 0) translate3d(-140vw, 0, 0) rotate(-6deg) scale(0.9)';
        });
  
        setTimeout(() => {
          card.style.transition = '';
          animatingCards.delete(card);
        }, PAGE_LEAVE_MS + 40);
      }
  
      // Render principal
      function render(){
        ticking = false;
        const t = getLocalT(window.scrollY);
        const nearest = Math.round(t);
  
        // Disparo de animación al avanzar de índice
        // Solo se dispara la animación de salida si el índice que pasa (lastNearest) no es el último.
        if (nearest > lastNearest && lastNearest < cards.length - 1) {
          const outgoing = cards[lastNearest];
          if (outgoing) pageLeaveLeft(outgoing);
        }
        lastNearest = nearest;
  
        const txFactor = vw * SPREAD_X;
  
        for (let i = 0; i < cards.length; i++){
          const card = cards[i];
          if (animatingCards.has(card)) continue;
  
          const d  = i - t;               // distancia al índice virtual
          const ad = Math.abs(d);
          
          let tx = d * txFactor;
          let s = 1 - (1 - SCALE_MIN) * (ad > 1 ? 1 : ad);
  
          // MODIFICACIÓN CLAVE: Fija la última card cuando t >= cards.length - 1 (mientras sale)
          if (i === cards.length - 1 && t >= cards.length - 1) {
              // Mantener la última card centrada y a escala 1 
              // Esto asegura que la última tarjeta (i) no se mueva horizontalmente (tx=0)
              // y mantenga la escala 1 (s=1) mientras t avanza más allá de su punto de anclaje (cards.length - 1)
              tx = 0; 
              s = 1; 
          } else {
              // Se calcula la escala normal solo si no es la última card o si t aún no ha llegado a su posición
              // escala entre 1 y SCALE_MIN según cercanía
              s = 1 - (1 - SCALE_MIN) * (ad > 1 ? 1 : ad);
          }
  
          const z = 1000 + (cards.length - Math.floor(ad * 10));
  
          card.style.transform = `translate3d(-50%, -50%, 0) translate3d(${tx}px, 0, 0) scale(${s})`;
          card.style.zIndex    = z;
  
          card.classList.toggle('active', i === nearest);
          card.classList.toggle('past',   i <  nearest);
  
          const img = card.querySelector('.card-visual img');
          if (img) {
            img.style.filter = (i === nearest) ? 'grayscale(0%)' : 'grayscale(100%)';
          }
        }
      }
  
      function onScroll(){
        if (!ticking){
          ticking = true;
          requestAnimationFrame(render);
        }
      }
      function onResize(){
        updateMetrics();
        requestAnimationFrame(render);
      }
  
      window.addEventListener('scroll', onScroll, { passive: true });
      window.addEventListener('resize', onResize, { passive: true });
  
      // Click: centra una card con scroll suave (usa el origen centro-a-centro)
      cards.forEach((c, i) => {
        c.addEventListener('click', () => {
          // El nuevo cálculo de targetY asegura que la card se alinee al centro
          const targetY = startOriginY + (i * animationUnitHeight);
          window.scrollTo({ top: targetY, behavior: 'smooth' });
        });
        c.addEventListener('dragstart', e => e.preventDefault());
      });
  
      // Primer render
      requestAnimationFrame(render);
  });
  </script>
  